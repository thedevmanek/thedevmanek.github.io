<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dev&#39;s Blog</title>
  
  <subtitle>A dev blog by dev</subtitle>
  <link href="https://thedevmanek.com/atom.xml" rel="self"/>
  
  <link href="https://thedevmanek.com/"/>
  <updated>2024-03-05T14:45:29.925Z</updated>
  <id>https://thedevmanek.com/</id>
  
  <author>
    <name>Dev Manek</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IMU for dummies:- Basics Of IMU</title>
    <link href="https://thedevmanek.com/2024/02/27/IMU-for-dummies-Basics-Of-IMU/"/>
    <id>https://thedevmanek.com/2024/02/27/IMU-for-dummies-Basics-Of-IMU/</id>
    <published>2024-02-27T16:06:43.000Z</published>
    <updated>2024-03-05T14:45:29.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../blog_images/IMUIntro2.gif" alt="alt text"></p><h2 id="What-does-an-IMU-consists-of"><a href="#What-does-an-IMU-consists-of" class="headerlink" title="What does an IMU consists of?"></a>What does an IMU consists of?</h2><p>An IMU comprises three major components:</p><ul><li>Accelerometer</li><li>Gyroscope</li><li>Magnetometer</li></ul><p>Each serves a specific purpose. To simplify, Iâ€™ll use the ICM-20948 IMU Iâ€™ve been working with to explain the function of each component. You can find the datasheet <a href="https://invensense.tdk.com/wp-content/uploads/2016/06/DS-000189-ICM-20948-v1.3.pdf">here</a></p><blockquote><p>  Note: This link might change with updates. Feel free to comment here, and Iâ€™ll update the blog.</p></blockquote><h3 id="Accelerometer"><a href="#Accelerometer" class="headerlink" title="Accelerometer"></a>Accelerometer</h3><p><img src="/../blog_images/accel.gif" alt="alt text"><br>Starting with the easiest component to understand, an accelerometer has mass that squeezes a piezoelectric material which in turn produces a charge proportional to the force. How? That will require a deeper dive into electronics.<br>The IMU gives acceleration in terms of F&#x3D;mg that is 1g,-2g etc. The information about the range will be given in the data sheet for example for ICM-20948 following ranges are possible 2g, Â±4g, Â±8g, and<br>Â±16g.<br><img src="/../blog_images/accel-config.png" alt="alt text"><br>You can select the desired range by saving a hexadecimal value inside the given register. We will see how to use these registers in upcoming blogs.<br>The Accelerometer will give you information on all three axes viz. X, Y and Z. Different IMUs store this information differently. For ICM-20948 here is how the information is stored in its registers.<br><img src="/../blog_images/accel-xout.png" alt="alt text"><br>A register can only store 8 bits but acceleration is stored in 16 bits thus we need two registers to get information about one particular axis.<br>We will see why this is the case and how to read values soon. I pinky promise.<br>Acceleration gives us information on the movement of the object in one direction. We have information about 3-DOF which is three degrees of freedom. Good but what about the other three, rotations? This is where a gyroscope comes into the picture.</p><h2 id="Gyroscope"><a href="#Gyroscope" class="headerlink" title="Gyroscope"></a>Gyroscope</h2><p><img src="/../blog_images/gyro.gif" alt="alt text"></p><p>A gyroscope provides the rate of rotation and angular position. How does it work though?<br>It is measured by fetching the value of Coriolis force. There are two masses suspended and they move in opposite directions. When a rotation is applied one mass moves up while the other mass moves down as seen in the animation.<br>The difference in the forces helps to calculate the angular velocity.<br>The information is stored similarly to the acceleration values. The registers have the following ranges Â±250 dps, Â±500 dps, Â±1000 dps, and Â±2000 dps. dps represents degrees per second.<br><img src="/../blog_images/gyro-config.png" alt="alt text"><br>The gyroscope stores the values of the rotation of the X, Y and Z axes in the same 16-bit format.<br><img src="/../blog_images/gyro-yout.png" alt="alt text"><br>You must have observed the term Gyro_Sensitivity. We will talk about this term when we are coding the driver for this IMU.</p><h2 id="Magnetometer"><a href="#Magnetometer" class="headerlink" title="Magnetometer"></a>Magnetometer</h2><p><img src="/../blog_images/magnet.gif" alt="alt text"><br>Wait how did this new component come into the picture. Donâ€™t we have everything to get started? What else are we missing?<br>The information from Magnetometer is very specific to certain algorithms. Gyroscopes have something called zero drift. As the name suggests even when the IMU is stable one can observe a non-zero reading from gyroscopes and it can get worse over time. For Roll and Pitch zero drift can be eliminated by Accelerometer measurements. However, we need a Magnetometer to eliminate the zero drift in Yaw. </p><p>Magnetometer works on the concept of the hall effect where the particle is moved mechanically inside a coil using a piezoelectric actuator making electric current. A change in magnetic field causes a change in current.</p><p>Our ICM gives us the range of Â±4900 Î¼T, and T represents Tesla the unit for magnetic flux.<br>The register map is a bit different since the magnetometer is a different chip.<br><img src="/../blog_images/magnet-register.png" alt="alt text"></p><h1 id="What-is-next"><a href="#What-is-next" class="headerlink" title="What is next?"></a>What is next?</h1><p>Okay so now that we know what each component does we can start writing the driver and after that, we will use IMU on a robot! How awesome is that!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../blog_images/IMUIntro2.gif&quot; alt=&quot;alt text&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;What-does-an-IMU-consists-of&quot;&gt;&lt;a href=&quot;#What-does-an-IMU-consists-of</summary>
      
    
    
    
    
    <category term="imu,robotics" scheme="https://thedevmanek.com/tags/imu-robotics/"/>
    
  </entry>
  
  <entry>
    <title>IMU for Dummies:- Introduction</title>
    <link href="https://thedevmanek.com/2024/02/26/IMU-for-dummies-Part-I/"/>
    <id>https://thedevmanek.com/2024/02/26/IMU-for-dummies-Part-I/</id>
    <published>2024-02-26T11:27:50.000Z</published>
    <updated>2024-02-27T16:07:30.983Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../blog_images/IMUIntro.gif" alt="alt text"></p><h2 id="Why-am-I-writing-about-IMU"><a href="#Why-am-I-writing-about-IMU" class="headerlink" title="Why am I writing about IMU?"></a>Why am I writing about IMU?</h2><p>When it comes to Inertial Measurement Units (IMU), the conversation often splits between embedded developers and roboticists. However, I aim to bridge that gap by offering insights from both perspectives. In this series, weâ€™ll delve into IMUs from both low-level and high-level angles, from understanding drivers to leveraging data for navigation systems.</p><h2 id="Understanding-IMU"><a href="#Understanding-IMU" class="headerlink" title="Understanding IMU"></a>Understanding IMU</h2><p>Inertial Measurement Unit or IMU is very common in robotics and I am sure you must have heard the name. But how important is it? It is said that before you start building a robot you order an IMU.<br>Well okâ€¦ but why?<br><img src="/../blog_images/Robot.gif" alt="Robot Navigation"><br>Tracking the motion of the robot is very important. Being accurate is one of the key requirements. To move a robot from point A to point B. You need to have the following information.</p><ul><li>Start point</li><li>Endpoint</li><li>Current position</li></ul><p>What IMU helps in is findnig the  current position of the Robot.<br>Seems easy right?<br>Plug in some rotary encoders and you are good to go!<br><em>Problem Solved!</em><br>Nope, having information from rotary encoders will just give you distance. Bigger problem is that that even if you have something like omni wheels from which you can also determnine direction. In real world things do not work as expected.<br><img src="/../blog_images/RobotDrift.gif" alt="alt text"></p><p>Although the wheels show you that it is moving towards the goal the robot has actually moved away from the path.</p><p>This is why IMU is used, to find the exact location of the robot in any given moment.</p><h2 id="Next-Part"><a href="#Next-Part" class="headerlink" title="Next Part"></a>Next Part</h2><p>In the next part I will talk about the basic components of an IMU and their limits. We will dive into datasheets.Next blog is going to be long so be prepared for it with a cuppa coffee and fresh mind.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../blog_images/IMUIntro.gif&quot; alt=&quot;alt text&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Why-am-I-writing-about-IMU&quot;&gt;&lt;a href=&quot;#Why-am-I-writing-about-IMU&quot; cla</summary>
      
    
    
    
    
    <category term="robotics,imu" scheme="https://thedevmanek.com/tags/robotics-imu/"/>
    
  </entry>
  
  <entry>
    <title>Developing IoT Projects with ESP32-Second Edition:A Review</title>
    <link href="https://thedevmanek.com/2023/12/29/Developing-IoT-Projects-with-ESP32-Second-Edition-A-Review/"/>
    <id>https://thedevmanek.com/2023/12/29/Developing-IoT-Projects-with-ESP32-Second-Edition-A-Review/</id>
    <published>2023-12-29T18:16:00.000Z</published>
    <updated>2024-01-04T12:52:17.821Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../blog_images/learning.oreilly.jpeg" alt="Image"></p><blockquote><p>Disclaimer: I hereby declare that I have been solicited by Maran Fernandes to furnish authentic feedback regarding the book titled â€œDeveloping IoT Projects with ESP32-Second Edition.â€ It is imperative to underscore that my evaluation remains entirely impartial, and I wish to emphasize that neither Mr. Fernandes nor his team has exerted any influence upon me to render a partial judgment. The opinions and remarks articulated in this blog post are exclusively my own, with the sole intention of providing insights to the best of my capability.<br>Cheers! ğŸ»</p></blockquote><h1 id="An-Overview"><a href="#An-Overview" class="headerlink" title="An Overview:"></a>An Overview:</h1><p>Upon delving into the initial pages, I swiftly grasped the bookâ€™s overarching objective. It endeavors to explore the IoT ecosystem through diverse examples, skillfully balancing practical applications with essential theoretical underpinnings. Each chapter seamlessly commences with fundamental theories, key concepts, or a project blueprint, seamlessly transitioning to the practical implementation through code.</p><h1 id="The-Review"><a href="#The-Review" class="headerlink" title="The Review"></a>The Review</h1><p>The book positions itself not as the definitive guide to ESP32 but as a valuable companion for comprehending and implementing a myriad of examples that showcase the robust capabilities of ESP32-based systems and ESP-IDF. It offers a distinctive perspective on IoT, aiming to maximize knowledge in my humble opinion.</p><h2 id="The-Dilemma-of-Target-Audience-ğŸ‘¥"><a href="#The-Dilemma-of-Target-Audience-ğŸ‘¥" class="headerlink" title="The Dilemma of Target Audience ğŸ‘¥"></a>The Dilemma of Target Audience ğŸ‘¥</h2><p>This book is not tailored for absolute beginners or hobbyists; both may find the substantial amount of code and theoretical content challenging, especially if they lack prior experience with electronics or object-oriented programming (OOP). While the book doesnâ€™t explicitly position itself for novices, it remains firmly rooted in the technical aspects of IoT, providing extensive insights into using PlatformIO and ESP-IDF.</p><h2 id="A-Unique-Programming-Language-Choice-ğŸ’»"><a href="#A-Unique-Programming-Language-Choice-ğŸ’»" class="headerlink" title="A Unique Programming Language Choice ğŸ’»"></a>A Unique Programming Language Choice ğŸ’»</h2><p>Rather than utilizing Arduino C++ or MISRA C, the book adopts a robust C++-based system for ESP-IDF. While this language choice may initially surprise readers, a deeper exploration in later chapters reveals its purposeâ€”to maintain consistency with libraries and leverage object-oriented programming for enhanced code modularity. The initial hesitation I felt was quickly overcome as the rationale became apparent.</p><h2 id="The-Exponential-Curve-ğŸ“ˆ"><a href="#The-Exponential-Curve-ğŸ“ˆ" class="headerlink" title="The Exponential Curve ğŸ“ˆ"></a>The Exponential Curve ğŸ“ˆ</h2><p>The book sets a deliberate pace in the first and second chapters, gradually intensifying in the third. While it attempts to sustain this momentum, the need to cover substantial content in smaller chapters presents a challenge. Keeping up with the increasing complexity may become demanding in the later chapters.</p><h2 id="Managing-Expectations"><a href="#Managing-Expectations" class="headerlink" title="Managing Expectations"></a>Managing Expectations</h2><p>Prospective buyers should not expect exhaustive coverage of ESP-IDF and IoT; disappointment awaits those seeking comprehensive insights. The book serves as a tool to reinforce prior knowledge of IoT systems and C++, facilitating the creation of practical, real-life projects that can serve as a foundation for future endeavors.</p><h2 id="The-Internet-Part-â˜"><a href="#The-Internet-Part-â˜" class="headerlink" title="The Internet Part â˜"></a>The Internet Part â˜</h2><p>Despite the titleâ€™s emphasis on the Internet aspect of IoT, the book remains narrowly focused on IoT concepts, omitting coverage of Bluetooth, Zigbee, and other essential protocols. While the decision to maintain focus is understood, a brief introduction to these technologies could have added valuable context.</p><h2 id="Hardware-Requirements-ğŸ”Œ"><a href="#Hardware-Requirements-ğŸ”Œ" class="headerlink" title="Hardware Requirements ğŸ”Œ"></a>Hardware Requirements ğŸ”Œ</h2><p>To follow along, readers are required to invest at least $80 in hardware. Despite potential backlash, I commend the authors for this decision, as adequate hardware is essential for a meaningful learning experience. Taking a firm stand on this ensures readers gain practical insights from the book.</p><h2 id="Book-Design-ğŸ¯"><a href="#Book-Design-ğŸ¯" class="headerlink" title="Book Design ğŸ¯"></a>Book Design ğŸ¯</h2><p>The book employs a unique design, delving into theory, hardware, software, and troubleshooting in each chapter. While the first three aspects are adequately covered, troubleshooting is addressed in a chapter-specific manner. Given that troubleshooting is integral to IoT, a more comprehensive approach in helping readers understand and overcome failures would be beneficial.</p><h2 id="Holding-Hands-ğŸ¤"><a href="#Holding-Hands-ğŸ¤" class="headerlink" title="Holding Hands ğŸ¤"></a>Holding Hands ğŸ¤</h2><p>The book adopts a guiding approach, holding readersâ€™ hands through each step. While this may enhance reader satisfaction, it could hinder true learning, as some readers may resort to copying code without fully grasping the concepts. The increasing pace in later chapters may result in reader frustration and potential abandonment.</p><h1 id="Final-Words"><a href="#Final-Words" class="headerlink" title="Final Words"></a>Final Words</h1><p>Despite its caveats, the book effectively achieves its intended goals, offering a comprehensive exploration of TinyML and Edge Computing concepts. I wholeheartedly recommend it as a must-read for individuals keen on IoT, possessing a good-enough programming background. Even those already entrenched in the industry may find this book surprising, thanks to its distinctive approach to programming and insightful explanations of various libraries. The authorâ€™s wealth of experiences contributes significantly to making this book a compelling and enriching read.</p><h1 id="Where-to-buy"><a href="#Where-to-buy" class="headerlink" title="Where to buy?"></a>Where to buy?</h1><p>You can buy this book on the Packtâ€™s website</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../blog_images/learning.oreilly.jpeg&quot; alt=&quot;Image&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Disclaimer: I hereby declare that I have been solicited</summary>
      
    
    
    
    
    <category term="esp32,book review" scheme="https://thedevmanek.com/tags/esp32-book-review/"/>
    
  </entry>
  
  <entry>
    <title>Day2:-ESP-IDF messing around with CMake</title>
    <link href="https://thedevmanek.com/2023/12/05/ESP-IDF-Messing-around-with-nimble-BLE-peripheral/"/>
    <id>https://thedevmanek.com/2023/12/05/ESP-IDF-Messing-around-with-nimble-BLE-peripheral/</id>
    <published>2023-12-05T13:55:36.000Z</published>
    <updated>2023-12-29T18:16:43.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Adding-a-new-component-ble-peripheral"><a href="#Adding-a-new-component-ble-peripheral" class="headerlink" title="Adding a new component - ble peripheral"></a>Adding a new component - ble peripheral</h2><p>Now that the setup is complete, letâ€™s talk about components. Code modularity is crucial, and in ESP-IDF, we achieve that by creating components. However, creating a component requires some knowledge of CMake and C. A component is essentially a standalone set of code that can be used in the main file or other components. Hereâ€™s a quick look at my code structure.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">â”œâ”€â”€ CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">â”œâ”€â”€ components</span><br><span class="line">â”‚Â Â  â”œâ”€â”€ common</span><br><span class="line">â”‚Â Â  â”‚Â Â  â”œâ”€â”€ nimble_central_utils</span><br><span class="line">â”‚Â Â  â”‚Â Â  â””â”€â”€ nimble_peripheral_utils</span><br><span class="line">â”‚Â Â  â””â”€â”€ nimble-ble-prph</span><br><span class="line">â”‚Â Â      â”œâ”€â”€ CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">â”‚Â Â      â”œâ”€â”€ gatt_svr<span class="selector-class">.c</span></span><br><span class="line">â”‚Â Â      â”œâ”€â”€ include</span><br><span class="line">â”‚Â Â      â”œâ”€â”€ Kconfig<span class="selector-class">.projbuild</span></span><br><span class="line">â”‚Â Â      â””â”€â”€ nimble-ble-prph<span class="selector-class">.c</span></span><br><span class="line">â”œâ”€â”€ dependencies<span class="selector-class">.lock</span></span><br><span class="line">â”œâ”€â”€ LICENSE</span><br><span class="line">â”œâ”€â”€ <span class="selector-tag">main</span></span><br><span class="line">â”‚Â Â  â”œâ”€â”€ CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">â”‚Â Â  â”œâ”€â”€ idf_component<span class="selector-class">.yml</span></span><br><span class="line">â”‚Â Â  â””â”€â”€ <span class="selector-tag">main</span><span class="selector-class">.c</span></span><br><span class="line">â”œâ”€â”€ README<span class="selector-class">.md</span></span><br><span class="line">â”œâ”€â”€ sdkconfig</span><br><span class="line">â”œâ”€â”€ sdkconfig<span class="selector-class">.defaults</span></span><br><span class="line">â””â”€â”€ sdkc</span><br></pre></td></tr></table></figure><p>The <code>common</code> directory holds essential files frequently utilized alongside a module. Meanwhile, the <code>nimble-ble-prph</code> component is centered around the <code>nimble-ble-prph.c</code> file, housing the bulk of the code.</p><h2 id="CMake-structure-for-the-project"><a href="#CMake-structure-for-the-project" class="headerlink" title="CMake structure for the project"></a>CMake structure for the project</h2><p>Starting with the high-level <code>CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">set</span>(EXTRA_COMPONENT_DIRS components/common/nimble_peripheral_utils)</span><br><span class="line"><span class="keyword">include</span>($ENV&#123;IDF_PATH&#125;/tools/cmake/<span class="keyword">project</span>.cmake)</span><br><span class="line"><span class="keyword">project</span>(assistive-shoulder-firmware)</span><br></pre></td></tr></table></figure><ul><li><code>cmake_minimum_required</code>: Specifying the CMake version.</li><li><code>set</code>: Defining the location for the essential <code>common</code> component.</li><li><code>include</code>: Incorporating essential configurations from <code>project.cmake</code>.</li></ul><p>Now, the core <code>CMakeLists.txt</code> in the main folder:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idf_component_register(SRCS <span class="string">&quot;main.c&quot;</span></span><br><span class="line">                    INCLUDE_DIRS <span class="string">&quot;.&quot;</span></span><br><span class="line">        REQUIRES nimble-ble-prph)</span><br></pre></td></tr></table></figure><ul><li><code>REQUIRES</code>: Integrating the <code>nimble-ble-prph</code> component as a dependency.</li></ul><p>Lastly, the pivotal <code>CMakeLists.txt</code> for the <code>nimble-ble-prph</code> component:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(srcs <span class="string">&quot;main.c&quot;</span>)</span><br><span class="line">idf_component_register(SRCS <span class="string">&quot;nimble-ble-prph.c&quot;</span> <span class="string">&quot;gatt_svr.c&quot;</span></span><br><span class="line">                       INCLUDE_DIRS <span class="string">&quot;include&quot;</span></span><br><span class="line">                       REQUIRES  nvs_flash nimble_peripheral_utils bt</span><br><span class="line">                       )</span><br></pre></td></tr></table></figure><ul><li><code>SRCS</code>: Enumerating source files for the compilation process.</li><li><code>INCLUDE_DIRS</code>: Specifying directories for header files.</li><li><code>REQUIRES</code>: Listing dependencies, including components like <code>nvs_flash</code>, <code>nimble_peripheral_utils</code>, and <code>bt</code>. CMake kindly reminds us if we miss one.Awww!ğŸ¥º<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Compilation failed because nimble-ble-prph.c (in &quot;nimble-ble-prph&quot; component) includes nvs_flash.h, provided by nvs_flash component(s).</span><br><span class="line">However, nvs_flash component(s) is not in the requirements list of &quot;nimble-ble-prph&quot;.</span><br><span class="line">To fix this, add nvs_flash to PRIV_REQUIRES list of idf_component_register call in /home/thedevmanek/Documents/Group Projects/assistive-shoulder-firmware/components/nimble-ble-prph/CMakeLists.txt.</span><br></pre></td></tr></table></figure>I want to talk more about what I am trying to do with <code>bluetooth</code> but I will do that in the next post.I know it is sad but I am hungry. BYE!</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Adding-a-new-component-ble-peripheral&quot;&gt;&lt;a href=&quot;#Adding-a-new-component-ble-peripheral&quot; class=&quot;headerlink&quot; title=&quot;Adding a new compo</summary>
      
    
    
    
    
    <category term="esp32,project" scheme="https://thedevmanek.com/tags/esp32-project/"/>
    
  </entry>
  
  <entry>
    <title>Day1:-ESP-IDF set up for a project</title>
    <link href="https://thedevmanek.com/2023/12/03/ESP-IDF-set-up-for-a-project/"/>
    <id>https://thedevmanek.com/2023/12/03/ESP-IDF-set-up-for-a-project/</id>
    <published>2023-12-03T12:14:43.000Z</published>
    <updated>2023-12-29T18:16:49.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="My-Setup"><a href="#My-Setup" class="headerlink" title="My Setup"></a>My Setup</h2><p>Iâ€™ve chosen CLion as my weapon of choice for this project, thanks to its slick built-in MISRA C support (weâ€™ll dig into that later). Currently, Iâ€™m cruising on my Dell G15 5515 Ryzen edition, running a dual-boot setup with Windows 11 and Ubuntu 22.04 LTS. (Yep, Iâ€™ve played with Arch, but no way am I sacrificing ROS for it!) </p><h2 id="Starting-Fresh-with-ESP-IDF"><a href="#Starting-Fresh-with-ESP-IDF" class="headerlink" title="Starting Fresh with ESP-IDF"></a>Starting Fresh with ESP-IDF</h2><p>I began by installing ESP-IDF from scratch. Everything seemed fine until I tried to install the specific esp32-c6 version. The compiler didnâ€™t find â€˜xtensa-esp32-elf-gccâ€™, which was weird for a fresh install.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CMake</span> <span class="title class_">Error</span> at /home/thedevmanek/esp/esp-idf/tools/cmake/project.<span class="symbol">cmake:</span><span class="number">448</span> </span><br><span class="line">(__project)<span class="symbol">:The</span> <span class="variable constant_">CMAKE_C_COMPILER</span><span class="symbol">:xtensa-esp32-elf-gcc</span></span><br></pre></td></tr></table></figure><p>To fix this, I reinstalled ESP-IDF without specifying the chip version, and that worked like a charm. I ran the â€œhello-worldâ€ example, and yay, it worked!</p><h2 id="Getting-the-Project-on-Track"><a href="#Getting-the-Project-on-Track" class="headerlink" title="Getting the Project on Track"></a>Getting the Project on Track</h2><p>I believe in starting a project right, and that means having a solid <a href="https://github.com/thedevmanek/assistive-shoulder-firmware/blob/main/README.md">README.md</a>. I goofed a bit during a pull request (PR) â€“ didnâ€™t do the squash and merge thing ğŸ˜­. No worries, though. I fixed it by reverting, adding a note about squash and merge in the README, and finally merging the PR.</p><p>Now, letâ€™s talk security for PRs. I added some important stuff:</p><ul><li><strong>Only Verified Commits Allowed:</strong> Making sure each commit is legit.</li><li><strong>Need at Least 1 Review to Merge:</strong> Double-checking things with another set of eyes.</li><li><strong>Sort Out Comments Before Merging:</strong> Making sure all comments are resolved before the merge happens.</li></ul><p>These steps might sound like a lot, but theyâ€™re just my way of making sure our project stays strong and secure.</p><p>Whenever I start a new project on GitHub, I make it a point to create a fresh file in the Projects folder. This little step goes a long way in keeping things organized. Itâ€™s like having a virtual whiteboard where I jot down features and track progress. Plus, it acts as a public commitment, showing that Iâ€™m all in for the success of the project. Itâ€™s my way of saying, â€œHey world, hereâ€™s what weâ€™re working on, and weâ€™re committed to making it awesome!â€ ğŸš€</p><h2 id="Some-Test-with-Bluetooth"><a href="#Some-Test-with-Bluetooth" class="headerlink" title="Some Test with Bluetooth"></a>Some Test with Bluetooth</h2><h3 id="Bluetooth-Testing-and-ESP32-C6-Quirk"><a href="#Bluetooth-Testing-and-ESP32-C6-Quirk" class="headerlink" title="Bluetooth Testing and ESP32-C6 Quirk"></a>Bluetooth Testing and ESP32-C6 Quirk</h3><blockquote><p>Pro tip: Stick to examples from the esp-idf installation folder. Itâ€™s a good shield against the notorious big breaking changes. And hey, consider using the LTS version for a smoother ride â€“ fewer surprises, fewer changes to handle.</p></blockquote><p>I ran some Bluetooth tests to ensure everything was smooth, but hereâ€™s the catch: ESP32-C6 doesnâ€™t work with Bluetooth classic; it only supports BLE. Save yourself from potential debugging headaches like this.</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined reference <span class="keyword">to</span> `esp_ble_gap_start_advertising<span class="comment">&#x27;</span></span><br><span class="line"><span class="symbol">collect2:</span> <span class="keyword">error</span>: ld returned <span class="number">1</span> <span class="keyword">exit</span> status</span><br></pre></td></tr></table></figure><blockquote><p>Quick tip: Always check the board compatibility info in the examples. The Espressif folks graciously provide this. Donâ€™t end up being a ğŸ¤¡ like me!</p></blockquote><h3 id="More-dumb-dev-moments"><a href="#More-dumb-dev-moments" class="headerlink" title="More dumb dev moments"></a>More dumb dev moments</h3><p>So, after ghosting ESP-IDF for a good two months, my lack of practice really hit me hard! Tried compiling my project and bam, two things I totally spaced on.</p><p>First off, this line will make your life hell if you ignore it!Newer ESP-IDF versions politely nudge you about it but try to be a good human.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REQUIRES esp_wifi bt esp_hid driver</span><br></pre></td></tr></table></figure><p>Donâ€™t forget to throw in all your source files. I didnâ€™t, and let me tell you, it led to some serious pondering about life choices. Just trust me on this one:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRCS <span class="string">&quot;bluetooth-controller.c&quot;</span></span><br></pre></td></tr></table></figure><p>Oh, and one more thing â€“ check that your <code>#include</code> game is strong, and in your main folderâ€™s CMakeLists, shout out the name of your component like:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REQUIRES bluetooth-controller</span><br></pre></td></tr></table></figure><p>Whatâ€™s a component, you ask? Iâ€™ll spill the beans in the next blog post. But first, coffee â˜•ï¸ and then time to get back to the grind!<br>PS:-I just got a new domain from <a href="https://porkbun.com/">porkbun</a> for just Â£7.6 a year so check them out ig?</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;My-Setup&quot;&gt;&lt;a href=&quot;#My-Setup&quot; class=&quot;headerlink&quot; title=&quot;My Setup&quot;&gt;&lt;/a&gt;My Setup&lt;/h2&gt;&lt;p&gt;Iâ€™ve chosen CLion as my weapon of choice for t</summary>
      
    
    
    
    
    <category term="esp32,project" scheme="https://thedevmanek.com/tags/esp32-project/"/>
    
  </entry>
  
</feed>
